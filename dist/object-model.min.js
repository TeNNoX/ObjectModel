// ObjectModel v4.0.5 - http://objectmodel.js.org
// MIT License - Sylvain Pollet-Villard
const e=Object.getPrototypeOf,t=Object.setPrototypeOf,r=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n=(e,t)=>t instanceof e,i=e=>"function"==typeof e,o=e=>e&&"object"==typeof e,s=t=>o(t)&&e(t)===Object.prototype,l=e=>e&&i(e[Symbol.iterator]),a=(e,t)=>new Proxy(e,t),u=(e,t={})=>{for(let r in t)if(s(t[r])){let n={};u(n,e[r]),u(n,t[r]),e[r]=n}else e[r]=t[r];return e},f=(e,t,r,n=!1)=>{Object.defineProperty(e,t,{value:r,enumerable:n,writable:!0,configurable:!0})},c=(e,r,n)=>{e.prototype=Object.assign(Object.create(r.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n),t(e,r)},p=Symbol(),h=Symbol(),d=Symbol(),g=(e,r,i,o,s,l)=>{let u=function(e=u.default,t){return l&&!n(u,this)?new u(e):(o&&(e=o(e,u,this)),t===h||S(u,e)?s?a(e,s(u)):e:void 0)};return i&&c(u,i),t(u,r.prototype),u.constructor=r,u.definition=e,u.assertions=[...u.assertions],f(u,"errors",[]),delete u.name,u},y=(e,t,r)=>n(t,e)?e:(o(e)||i(e)||void 0===e||v(t.errors,Object,e),u(r,t.default),t.parentClass&&u(e,new t.parentClass(e)),u(r,e),r),m=(e,t,r)=>(c(e,t,r),e.assertions.push(...t.assertions),e),v=(e,t,r,n,i)=>{e.push({expected:t,received:r,path:n,message:i})},b=(e,t=e.errorCollector)=>{let r=e.errors.length;if(r>0){let r=e.errors.map(e=>(e.message||(e.message="expecting "+(e.path?e.path+" to be ":"")+j(e.expected)+", got "+(null!=e.received?(e=>Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)[1])(e.received)+" ":"")+C(e.received)),e));e.errors.length=0,t.call(e,r)}return r},O=t=>t&&e(t)&&n(E,e(t).constructor),$=e=>{if(s(e))Object.keys(e).map(t=>{e[t]=$(e[t])});else{if(!Array.isArray(e))return[e];if(1===e.length)return[e[0],void 0,null]}return e},j=(e,t)=>{let r=$(e).map(e=>C(e,t));return r.length>1?r.join(" or "):r[0]},w=(e,t=[])=>((t=[].concat(t)).length>0&&(e=t.reduce((e,t)=>e.concat(t),[].concat(e)).filter((e,t,r)=>r.indexOf(e)===t)),e),S=(e,t)=>(e[p](t,null,e.errors,[],!0),!b(e)),P=(e,t,r,i,o,l)=>{let a=o.indexOf(t);if(-1!==a&&-1!==o.indexOf(t,a+1))return e;if(Array.isArray(t)&&1===t.length&&null!=e&&(t=t[0]),n(E,t))l&&(e=M(e,t)),t[p](e,r,i,o.concat(t));else if(s(t))Object.keys(t).map(n=>{let s=e?e[n]:void 0;P(s,t[n],k(r,n),i,o,l)});else{if($(t).some(t=>A(e,t,r,o)))return l?M(e,t):e;v(i,t,e,r)}return e},A=(e,t,r,o,l)=>{if(t===z)return!0;if(null==e)return e===t;if(s(t)||n(E,t)){let n=[];return P(e,t,r,n,o,l),!n.length}return n(RegExp,t)?t.test(e):t===Number||t===Date?e.constructor===t&&!isNaN(e):e===t||i(t)&&n(t,e)||e.constructor===t},x=(e,t,r,n=t.errors)=>{for(let o of t.assertions){let s;try{s=o.call(t,e)}catch(e){s=e}if(!0!==s){let l=i(o.description)?o.description:(e,t)=>`assertion "${o.description}" returned ${C(e)} `+`for ${r?r+" =":"value"} ${C(t)}`;v(n,o,e,r,l.call(t,s,e,r))}}},C=(e,t=[])=>{if(t.length>15||t.includes(e))return"...";if(null==e)return String(e);if("string"==typeof e)return`"${e}"`;if(n(E,e))return e.toString(t);if(t.unshift(e),i(e))return e.name||e.toString();if(n(Map,e)||n(Set,e))return C([...e]);if(Array.isArray(e))return`[${e.map(e=>C(e,t)).join(", ")}]`;if(e.toString&&e.toString!==Object.prototype.toString)return e.toString();if(o(e)){let r=Object.keys(e),n="\t".repeat(t.length);return`{${r.map(r=>`\n${n+r}: ${C(e[r],[...t])}`).join(", ")} ${r.length?`\n${n.slice(1)}`:""}}`}return String(e)},k=(e,t)=>e?e+"."+t:t,F=(e,t,n,i,o,s,l)=>{let a=k(n,o),u=e.conventionForPrivate(o),f=e.conventionForConstant(o),c=r(i,o),p=c&&Object.getOwnPropertyDescriptor(i,o);o in t&&(u&&!s||f&&void 0!==i[o])&&R(`modify ${u?"private":"constant"} property ${o}`,e),l(a),r(t,o)&&P(i[o],t[o],a,e.errors,[]),x(i,e,a);let h=e.errors.length;return h&&(c?Object.defineProperty(i,o,p):delete i[o],b(e)),!h},R=(e,t)=>{t.errors.push({message:"cannot "+e})},M=(e,t=[])=>{if(!e||s(t)||n(N,t)||O(e))return e;let r=$(t),i=[];for(let t of r)n(E,t)&&!n(N,t)&&t.test(e)&&i.push(t);return 1===i.length?new i[0](e,h):(i.length>1&&console.warn(`Ambiguous model for value ${C(e)}, could be ${i.join(" or ")}`),e)},D=(e,t,r,n,i)=>s(r)?a(e,T(t,r,n,i)):M(e,r),T=(t,n,o,l)=>{return{getPrototypeOf:t=>o?Object.prototype:e(t),get(e,u){if(u===d)return e;if("string"!=typeof u)return Reflect.get(e,u);let f=k(o,u),c=n[u];return!l&&u in n&&t.conventionForPrivate(u)?(R(`access to private property ${f}`,t),void b(t)):(e[u]&&r(e,u)&&!s(c)&&!O(e[u])&&(e[u]=M(e[u],c)),i(e[u])&&"constructor"!==u&&!l?(e=>a(e,{apply(e,t,r){l=!0;let n=Reflect.apply(e,t,r);return l=!1,n}}))(e[u]):(s(c)&&!e[u]&&(e[u]={}),D(e[u],t,c,f,l)))},set:(e,r,i)=>F(t,n,o,e,r,l,o=>Reflect.set(e,r,D(i,t,n[r],o))),deleteProperty:(e,r)=>F(t,n,o,e,r,l,()=>Reflect.deleteProperty(e,r)),defineProperty:(e,r,i)=>F(t,n,o,e,r,l,()=>Reflect.defineProperty(e,r,i)),has:(e,r)=>Reflect.has(e,r)&&Reflect.has(n,r)&&!t.conventionForPrivate(r),ownKeys:e=>Reflect.ownKeys(e).filter(e=>Reflect.has(n,e)&&!t.conventionForPrivate(e)),getOwnPropertyDescriptor(e,r){let i;return t.conventionForPrivate(r)||(i=Object.getOwnPropertyDescriptor(n,r),void 0!==i&&(i.value=e[r])),i}}};function E(e,t){return s(e)?new K(e,t):new N(e)}function N(e){return g(e,N)}function K(e){return g(e,K,Object,y,t=>T(t,e),!0)}Object.assign(E.prototype,{name:"Model",assertions:[],conventionForConstant:e=>e.toUpperCase()===e,conventionForPrivate:e=>"_"===e[0],toString(e){return r(this,"name")?this.name:j(this.definition,e)+(e=>e.length?`(${e.map(e=>e.name||e.description||e)})`:"")(this.assertions)},as(e){return f(this,"name",e),this},defaultTo(e){return this.default=e,this},[p](e,t,r,n){P(e,this.definition,t,r,n),x(e,this,t,r)},test(t,n){let i=this;for(;!r(i,"errorCollector");)i=e(i);let o,s=i.errorCollector;return i.errorCollector=e=>{o=!0,n&&n.call(this,e)},new this(t),i.errorCollector=s,!o},errorCollector(e){let t=new TypeError(e.map(e=>e.message).join("\n"));throw t.stack=t.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),t},assert(e,t=C(e)){return f(e,"description",t),this.assertions=this.assertions.concat(e),this}}),c(N,E,{extend(...e){let t=m(new N(w(this.definition,e)),this);for(let r of e)n(N,r)&&t.assertions.push(...r.assertions);return t}}),c(K,E,{defaultTo(e){let t=this.definition;for(let n in e)r(t,n)&&(e[n]=P(e[n],t[n],n,this.errors,[],!0));return b(this),this.default=e,this},toString(e){return C(this.definition,e)},extend(...t){let r={...this.definition},s={...this.prototype},l={...this.default},a=[];for(let e of t)n(E,e)&&(u(r,e.definition),u(l,e.default),a.push(...e.assertions)),i(e)&&u(s,e.prototype),o(e)&&u(r,e);let f=m(new K(r),this,s).defaultTo(l);return f.assertions=[...this.assertions,...a],e(this)!==K.prototype&&(f.parentClass=this),f},[p](e,t,r,n,i){if(o(e)){let o=this.definition;P(e[d]||e,o,t,r,n,i)}else v(r,this,e,t);x(e,this,t,r)}});const z=a(N(),{apply:(e,t,[r])=>Object.assign(Object.create(z),{definition:r})});z.definition=z,z.toString=()=>"Any",z.remaining=function(e){this.definition=e},c(z.remaining,z,{toString(){return"..."+j(this.definition)}}),z[Symbol.iterator]=function*(){yield new z.remaining(this.definition)};const U=(e,t,n,o,s,l,u)=>g(n,t,e,o,t=>Object.assign({getPrototypeOf:()=>t.prototype,get(n,o){if(o===d)return n;let u=n[o];return i(u)?a(u,{apply(i,a,u){if(r(l,o)){let[r,a=u.length-1,f]=l[o];for(let n=r;n<=a;n++){let r=f?f(n):t.definition;u[n]=P(u[n],r,`${e.name}.${o} arguments[${n}]`,t.errors,[],!0)}if(t.assertions.length>0){let e=s(n);i.apply(e,u),x(e,t,`after ${o} mutation`)}b(t)}return i.apply(n,u)}}):u}},u));function W(e){let t=U(Array,W,e,e=>Array.isArray(e)?e.map(e=>M(e,t.definition)):e,e=>[...e],{copyWithin:[],fill:[0,0],pop:[],push:[0],reverse:[],shift:[],sort:[],splice:[2],unshift:[0]},{set:(e,r,n)=>Z(t,e,r,n,(e,t)=>e[r]=t,!0),deleteProperty:(e,r)=>Z(t,e,r,void 0,e=>delete e[r])});return t}c(W,E,{toString(e){return"Array of "+j(this.definition,e)},[p](e,t,r,n){Array.isArray(e)?(e[d]||e).forEach((e,i)=>P(e,this.definition,`${t||"Array"}[${i}]`,r,n)):v(r,this,e,t),x(e,this,t,r)},extend(...e){return m(new W(w(this.definition,e)),this)}});let Z=(e,t,r,n,i,o)=>{let s=`Array[${r}]`;+r>=0&&(o||r in t)&&(n=P(n,e.definition,s,e.errors,[],!0));let l=[...t];i(l),x(l,e,s);let a=!b(e);return a&&i(t,n),a};function _(...e){return g({arguments:e},_,Function,null,e=>({getPrototypeOf:()=>e.prototype,get:(e,t)=>t===d?e:e[t],apply(t,r,i){let o,s=e.definition,l=s.arguments.find(e=>n(z.remaining,e)),a=l?Math.max(i.length,s.arguments.length-1):s.arguments.length;for(let t=0;t<a;t++){let r=l&&t>=s.arguments.length-1?l.definition:s.arguments[t];i[t]=P(i[t],r,`arguments[${t}]`,e.errors,[],!0)}return x(i,e,"arguments"),e.errors.length||(o=Reflect.apply(t,r,i),"return"in s&&(o=P(o,s.return,"return value",e.errors,[],!0))),b(e),o}}))}function q(e,t){let r=e=>0===e?n.definition.key:n.definition.value,n=U(Map,q,{key:e,value:t},e=>l(e)?new Map([...e].map(e=>e.map((e,t)=>M(e,r(t))))):e,e=>new Map(e),{set:[0,1,r],delete:[],clear:[]});return n}function B(e){let t=U(Set,B,e,e=>l(e)?new Set([...e].map(e=>M(e,t.definition))):e,e=>new Set(e),{add:[0,0],delete:[],clear:[]});return t}c(_,E,{toString(e=[]){let t=`Function(${this.definition.arguments.map(t=>j(t,[...e])).join(", ")})`;return"return"in this.definition&&(t+=" => "+j(this.definition.return,e)),t},return(e){return this.definition.return=e,this},extend(e,t){let r=this.definition.arguments,n=e.map((t,n)=>w(n in r?r[n]:[],e[n])),i=w(this.definition.return,t);return m(new _(...n).return(i),this)},[p](e,t,r){i(e)||v(r,"Function",e,t)}}),c(q,E,{toString(e){return`Map of ${j(this.definition.key,e)} : ${j(this.definition.value,e)}`},[p](e,t,r,i){if(n(Map,e)){t=t||"Map";for(let[n,o]of e)P(n,this.definition.key,`${t} key`,r,i),P(o,this.definition.value,`${t}[${C(n)}]`,r,i)}else v(r,this,e,t);x(e,this,t,r)},extend(e,t){return m(new q(w(this.definition.key,e),w(this.definition.value,t)),this)}}),c(B,E,{toString(e){return"Set of "+j(this.definition,e)},[p](e,t,r,i){if(n(Set,e))for(let n of e.values())P(n,this.definition,`${t||"Set"} value`,r,i);else v(r,this,e,t);x(e,this,t,r)},extend(...e){return m(new B(w(this.definition,e)),this)}});export{z as Any,W as ArrayModel,N as BasicModel,_ as FunctionModel,q as MapModel,E as Model,K as ObjectModel,B as SetModel};
//# sourceMappingURL=object-model.min.js.map
