// ObjectModel v3.5.4 - http://objectmodel.js.org
// MIT License - Sylvain Pollet-Villard
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.window=e.window||{})}(this,function(e){"use strict";const t=e=>Object.getPrototypeOf(e),r=(e,t)=>Object.setPrototypeOf(e,t),n=(e,t)=>e.hasOwnProperty(t),i=(e,t)=>t instanceof e,o=e=>"function"==typeof e,s=e=>"object"==typeof e,l=e=>e&&s(e)&&t(e)===Object.prototype,a=(e,t)=>new Proxy(e,{apply:t}),u=(e,t,r)=>new Proxy(e,Object.assign({getPrototypeOf:()=>t.prototype},r)),f=(e,t={},r)=>{for(let n in t)if(r&&l(t[n])){let i={};f(i,e[n],r),f(i,t[n],r),e[n]=i}else e[n]=t[n]},c=(e,t,r,n=!1)=>{Object.defineProperty(e,t,{value:r,enumerable:n,writable:!0,configurable:!0})},p=(e,t)=>{r(e,t.prototype),c(e,"constructor",t)},d=(e,t,n)=>{e.prototype=Object.assign(Object.create(t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n),r(e,t)},h=Symbol(),y=Symbol(),g=Symbol(),v=Symbol(),m=(e,t)=>{e.definition=t,e.assertions=[...e.assertions],c(e,"errors",[]),delete e.name},b=(e,t,r)=>(d(e,t,r),e.assertions.push(...t.assertions),e),j=(e,t,r,n,i)=>{e.push({expected:t,received:r,path:n,message:i})},O=(e,t=e.errorCollector)=>{let r=e.errors.length;if(r>0){let r=e.errors.map(e=>{if(!e.message){let t=Array.isArray(e.expected)?e.expected:[e.expected];e.message="expecting "+(e.path?e.path+" to be ":"")+t.map(e=>k(e)).join(" or ")+", got "+(null!=e.received?(e=>Object.prototype.toString.call(e).match(/\s([a-zA-Z]+)/)[1])(e.received)+" ":"")+k(e.received)}return e});e.errors=[],t.call(e,r)}return r},w=e=>e&&i(K,t(e).constructor),$=e=>{if(l(e))Object.keys(e).map(t=>{e[t]=$(e[t])});else{if(!Array.isArray(e))return[e];if(1===e.length)return[...e,void 0,null]}return e},S=(e,t)=>{let r=$(e).map(e=>k(e,t));return r.length>1?`(${r.join(" or ")})`:r[0]},P=(e,t=[])=>(Array.isArray(t)||(t=[t]),t.length>0&&(e=t.reduce((e,t)=>e.concat(t),Array.isArray(e)?e.slice():[e]).filter((e,t,r)=>r.indexOf(e)===t)),e),x=(e,t,r,n,o)=>{let s=o.indexOf(t);if(-1!==s&&-1!==o.indexOf(t,s+1))return e;if(e=D(e,t),i(K,t))t[y](e,r,n,o.concat(t));else if(l(t))Object.keys(t).map(i=>{let s=e?e[v]?e[v](i):e[i]:void 0;x(s,t[i],F(r,i),n,o)});else{if($(t).some(t=>A(e,t,r,o)))return e;j(n,t,e,r)}return e},A=(e,t,r,n)=>{if(null==e)return e===t;if(l(t)||i(K,t)){let i=[];return x(e,t,r,i,n),!i.length}return i(RegExp,t)?t.test(e):t===Number||t===Date?e.constructor===t&&!isNaN(e):e===t||o(t)&&i(t,e)||e.constructor===t},M=(e,t,r,n=t.errors)=>{for(let i of t.assertions){let s;try{s=i.call(t,e)}catch(e){s=e}if(!0!==s){let l=o(i.description)?i.description:(e,t)=>`assertion "${i.description}" returned ${k(e)} `+`for ${r?r+" =":"value"} ${k(t)}`;j(n,i,e,r,l.call(t,s,e,r))}}},k=(e,t=[])=>{if(t.length>15||t.includes(e))return"...";if(null==e)return String(e);if("string"==typeof e)return`"${e}"`;if(i(K,e))return e.toString(t);if(t.unshift(e),o(e))return e.name||e.toString();if(i(Map,e)||i(Set,e))return k([...e]);if(Array.isArray(e))return`[${e.map(e=>k(e,t)).join(", ")}]`;if(e.toString!==Object.prototype.toString)return e.toString();if(e&&s(e)){let r=Object.keys(e),n="\t".repeat(t.length);return`{${r.map(r=>`\n${n+r}: ${k(e[r],t.slice())}`).join(",")} ${r.length?`\n${n.slice(1)}`:""}}`}return String(e)},F=(e,t)=>e?e+"."+t:t,R=(e,t,r,i,o,s,l)=>{let a=F(r,o),u=e.conventionForPrivate(o),f=e.conventionForConstant(o),c=n(i,o),p=c&&Object.getOwnPropertyDescriptor(i,o);o in t&&(u&&!s||f&&void 0!==i[o])&&C(`modify ${u?"private":"constant"} property ${o}`,e);let d=n(t,o);d||!e.sealed?(l(a),d&&x(i[o],t[o],a,e.errors,[]),M(i,e,a)):E(a,i[o],e.errors);let h=e.errors.length;return h&&(c?Object.defineProperty(i,o,p):delete i[o],O(e)),!h},C=(e,t)=>{t.errors.push({message:"cannot "+e})},E=(e,t,r)=>{r.push({path:e,received:t,message:`property ${e} is not declared in the sealed model definition`})},D=(e,t=[])=>{if(!e||l(t)||w(e))return e;let r=$(t),n=[];for(let t of r)i(K,t)&&t.test(e)&&n.push(t);if(1===n.length){let t=n[0];return i(z,t)?new t(e):t(e)}return n.length>1&&console.warn(`Ambiguous model for value ${k(e)}, could be ${n.join(" or ")}`),e},N=(e,t,r,i)=>{Object.keys(e).map(o=>{let s=e[o],a=F(i,o);n(t,o)?l(s)&&N(s,t[o],r,a):E(a,s,r)})},_=(e,r,i,s,u)=>{if(!l(i))return D(r,i);const f=e=>a(e,(e,t,r)=>{u=!0;let n=Reflect.apply(e,t,r);return u=!1,n});return new Proxy(r,{getPrototypeOf:()=>s?Object.prototype:t(r),get(t,r){if(r===g)return t;if(r===v)return f(e=>t[e]);if("string"!=typeof r)return Reflect.get(t,r);let a=F(s,r),c=i[r];return!u&&r in i&&e.conventionForPrivate(r)?(C(`access to private property ${a}`,e),void O(e)):(t[r]&&n(t,r)&&!l(c)&&!w(t[r])&&(t[r]=D(t[r],c)),o(t[r])&&"constructor"!==r?f(t[r]):(l(c)&&!t[r]&&(t[r]={}),_(e,t[r],c,a,u)))},set:(t,r,n)=>R(e,i,s,t,r,u,o=>Reflect.set(t,r,_(e,n,i[r],o))),deleteProperty:(t,r)=>R(e,i,s,t,r,u,()=>Reflect.deleteProperty(t,r)),defineProperty:(t,r,n)=>R(e,i,s,t,r,u,()=>Reflect.defineProperty(t,r,n)),has:(t,r)=>Reflect.has(t,r)&&Reflect.has(i,r)&&!e.conventionForPrivate(r),ownKeys:t=>Reflect.ownKeys(t).filter(t=>Reflect.has(i,t)&&!e.conventionForPrivate(t)),getOwnPropertyDescriptor(t,r){let n;return e.conventionForPrivate(r)||void 0!==(n=Object.getOwnPropertyDescriptor(i,r))&&(n.value=t[r]),n}})};function K(e,t){return l(e)?new z(e,t):new T(e)}function T(e){let t=function(e=t.default){return t.validate(e)?e:void 0};return p(t,T),m(t,e),t}function z(e,t){let r=function(e=r.default){return i(r,this)?i(r,e)?e:(i(Object,e)||void 0===e||j(r.errors,Object,e),f(this,r[h](e),!0),r.validate(this)?_(r,this,r.definition):void 0):new r(e)};return Object.assign(r,t),d(r,Object),p(r,z),m(r,e),r}Object.assign(K.prototype,{name:"Model",assertions:[],conventionForConstant:e=>e.toUpperCase()===e,conventionForPrivate:e=>"_"===e[0],toString(e){return S(this.definition,e)},as(e){return c(this,"name",e),this},defaultTo(e){return this.default=e,this},[y](e,t,r,n){x(e,this.definition,t,r,n),M(e,this,t,r)},validate(e,t){return this[y](e,null,this.errors,[]),!O(this,t)},test(e){let r=this;for(;!n(r,"errorCollector");)r=t(r);let i,o=r.errorCollector;return r.errorCollector=(()=>{i=!0}),new this(e),r.errorCollector=o,!i},errorCollector(e){let t=new TypeError(e.map(e=>e.message).join("\n"));throw t.stack=t.stack.replace(/\n.*object-model(.|\n)*object-model.*/,""),t},assert(e,t=k(e)){return c(e,"description",t),this.assertions=this.assertions.concat(e),this}}),d(T,K,{extend(...e){let t=b(new T(P(this.definition,e)),this);for(let r of e)i(T,r)&&t.assertions.push(...r.assertions);return t}}),d(z,K,{sealed:!1,defaults(e){return Object.assign(this.prototype,e),this},toString(e){return k(this.definition,e)},extend(...e){let r=Object.assign({},this.definition),n=[],l={};f(l,this.prototype,!1);for(let t of e)i(K,t)&&(f(r,t.definition,!0),n.push(...t.assertions)),o(t)&&f(l,t.prototype,!0),s(t)&&f(r,t,!0);let a=b(new z(r),this,l);return a.assertions=[...this.assertions,...n],t(this)!==z.prototype&&(a[h]=(e=>{let t=new this(e);return f(e,t,!0),e})),a},[h]:e=>e,[y](e,t,r,n){if(s(e)){let i=this.definition;x(e,i,t,r,n),this.sealed&&N(e,i,r)}else j(r,this,e,t);M(e,this,t,r)}});let B=["pop","push","reverse","shift","sort","splice","unshift"];function I(e){let t=function(e=t.default){if(t.validate(e))return u(e,t,{get(r,n){if(n===g)return r;let i=r[n];return o(i)?a(i,(i,o,s)=>{if(B.includes(n)){let e=r.slice();i.apply(e,s),t.validate(e)}let l=i.apply(r,s);return e.forEach((e,n)=>r[n]=D(e,t.definition)),l}):i},set:(e,r,n)=>U(e,r,n,t),deleteProperty:(e,r)=>!(r in e)||U(e,r,void 0,t)})};return d(t,Array),p(t,I),m(t,e),t}d(I,K,{toString(e){return"Array of "+S(this.definition,e)},[y](e,t,r,n){Array.isArray(e)?e.forEach((i,o)=>{e[o]=x(i,this.definition,`${t||"Array"}[${o}]`,r,n)}):j(r,this,e,t),M(e,this,t,r)},extend(...e){return b(new I(P(this.definition,e)),this)}});let U=(e,t,r,n)=>{let i=`Array[${t}]`;parseInt(t)===+t&&t>=0&&(r=x(r,n.definition,i,n.errors,[]));let o=e.slice();o[t]=r,M(o,n,i);let s=!O(n);return s&&(e[t]=r),s};function Z(...e){let t=function(e=t.default){if(t.validate(e))return u(e,t,{get:(e,t)=>t===g?e:e[t],apply(e,r,n){let i,o=t.definition;return o.arguments.forEach((e,r)=>{n[r]=x(n[r],e,`arguments[${r}]`,t.errors,[])}),M(n,t,"arguments"),t.errors.length||(i=Reflect.apply(e,r,n),"return"in o&&(i=x(i,o.return,"return value",t.errors,[]))),O(t),i}})};return d(t,Function),p(t,Z),m(t,{arguments:e}),t}d(Z,K,{toString(e=[]){let t=`Function(${this.definition.arguments.map(t=>S(t,e.slice())).join(", ")})`;return"return"in this.definition&&(t+=" => "+S(this.definition.return,e)),t},return(e){return this.definition.return=e,this},extend(e,t){let r=this.definition.arguments,n=e.map((t,n)=>P(n in r?r[n]:[],e[n])),i=P(this.definition.return,t);return b(new Z(...n).return(i),this)},[y](e,t,r){o(e)||j(r,"Function",e,t)}}),Z.prototype.assert(function(e){return!(e.length>this.definition.arguments.length)||e},function(e){return`expecting ${this.definition.arguments.length} arguments for ${k(this)}, got ${e.length}`});let q=["set","delete","clear"];function G(e,t){let r=function(e=r.default){let t=e=>["key","value"].map((t,n)=>D(e[n],r.definition[t])),n=new Map([...e].map(t));if(r.validate(n))return u(n,r,{get(e,n){if(n===g)return e;let i=e[n];return o(i)?a(i,(i,o,s)=>{if("set"===n&&(s=t(s)),q.includes(n)){let t=new Map(e);i.apply(t,s),r.validate(t)}return i.apply(e,s)}):i}})};return d(r,Map),p(r,G),m(r,{key:e,value:t}),r}d(G,K,{toString(e){let{key:t,value:r}=this.definition;return`Map of ${S(t,e)} : ${S(r,e)}`},[y](e,t,r,n){if(i(Map,e)){t=t||"Map";for(let[i,o]of e)x(i,this.definition.key,`${t} key`,r,n),x(o,this.definition.value,`${t}[${k(i)}]`,r,n)}else j(r,this,e,t);M(e,this,t,r)},extend(e,t){let{key:r,value:n}=this.definition;return b(new G(P(r,e),P(n,t)),this)}});let H=["add","delete","clear"];function J(e){let t=function(e=t.default){let r=e=>D(e,t.definition),n=new Set([...e].map(r));if(t.validate(n))return u(n,t,{get(e,n){if(n===g)return e;let i=e[n];return o(i)?a(i,(i,o,s)=>{if("add"===n&&(s[0]=r(s[0])),H.includes(n)){let r=new Set(e);i.apply(r,s),t.validate(r)}return i.apply(e,s)}):i}})};return d(t,Set),p(t,J),m(t,e),t}d(J,K,{toString(e){return"Set of "+S(this.definition,e)},[y](e,t,r,n){if(i(Set,e))for(let i of e.values())x(i,this.definition,`${t||"Set"} value`,r,n);else j(r,this,e,t);M(e,this,t,r)},extend(...e){return b(new J(P(this.definition,e)),this)}}),e.Model=K,e.BasicModel=T,e.ObjectModel=z,e.ArrayModel=I,e.FunctionModel=Z,e.MapModel=G,e.SetModel=J,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=object-model.min.js.map
