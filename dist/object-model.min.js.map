{"version":3,"file":"object-model.min.js","sources":["../src/basic-model.js","../src/object-model.js","../src/model.js","../src/array-model.js","../src/function-model.js","../src/map-model.js","../src/set-model.js","../src/helpers.js","../src/definition.js"],"sourcesContent":["import {extend, is, setConstructor} from \"./helpers\"\nimport {extendDefinition} from \"./definition\"\nimport {extendModel, initModel, Model} from \"./model\"\n\n\nexport default function BasicModel(def) {\n\tlet model = function (val = model.default) {\n\t\treturn model.validate(val) ? val : undefined\n\t}\n\n\tsetConstructor(model, BasicModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(BasicModel, Model, {\n\textend(...newParts) {\n\t\tlet child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this)\n\t\tfor (let part of newParts) {\n\t\t\tif (is(BasicModel, part)) child.assertions.push(...part.assertions)\n\t\t}\n\n\t\treturn child\n\t}\n})","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\r\nimport {cast, checkAssertions, checkDefinition} from \"./definition\"\r\nimport {\r\n\t_constructor,\r\n\t_validate,\r\n\tcannot,\r\n\textend,\r\n\tformat,\r\n\tgetPath,\r\n\tgetProto,\r\n\thas,\r\n\tis,\r\n\tisFunction,\r\n\tisModelInstance,\r\n\tisObject,\r\n\tisPlainObject,\r\n\tisString,\r\n\tmapProps,\r\n\tmerge,\r\n\tObjectProto,\r\n\tproxify,\r\n\tsetConstructor\r\n} from \"./helpers\"\r\n\r\nexport default function ObjectModel(def, params) {\r\n\tlet model = function (obj = model.default) {\r\n\t\tlet instance = this\r\n\t\tif (!is(model, instance)) return new model(obj)\r\n\t\tif (is(model, obj)) return obj\r\n\r\n\t\tmerge(instance, model[_constructor](obj), true)\r\n\t\tif (!model.validate(instance)) return\r\n\t\treturn getProxy(model, instance, model.definition)\r\n\t}\r\n\r\n\tObject.assign(model, params)\r\n\textend(model, Object)\r\n\tsetConstructor(model, ObjectModel)\r\n\tinitModel(model, def)\r\n\treturn model\r\n}\r\n\r\nextend(ObjectModel, Model, {\r\n\tsealed: false,\r\n\r\n\tdefaults(p){\r\n\t\tObject.assign(this.prototype, p)\r\n\t\treturn this\r\n\t},\r\n\r\n\ttoString(stack){\r\n\t\treturn format(this.definition, stack)\r\n\t},\r\n\r\n\textend(...newParts){\r\n\t\tlet parent = this,\r\n\t\t    def = Object.assign({}, this.definition),\r\n\t\t    newAssertions = [],\r\n\t\t    proto = {}\r\n\r\n\t\tmerge(proto, parent.prototype, false)\r\n\r\n\t\tfor (let part of newParts) {\r\n\t\t\tif (is(Model, part)) {\r\n\t\t\t\tmerge(def, part.definition, true)\r\n\t\t\t\tnewAssertions.push(...part.assertions)\r\n\t\t\t}\r\n\t\t\tif (isFunction(part)) merge(proto, part.prototype, true)\r\n\t\t\tif (isObject(part)) merge(def, part, true)\r\n\t\t}\r\n\r\n\t\tlet submodel = extendModel(new ObjectModel(def), parent, proto)\r\n\t\tsubmodel.assertions = parent.assertions.concat(newAssertions)\r\n\r\n\t\tif(getProto(parent) !== ObjectModel.prototype) { // extended class\r\n\t\t\tsubmodel[_constructor] = (obj) => {\r\n\t\t\t\tlet parentInstance = new parent(obj)\r\n\t\t\t\tmerge(obj, parentInstance, true) // get modified props from parent class constructor\r\n\t\t\t\treturn obj\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn submodel\r\n\t},\r\n\r\n\t[_validate](obj, path, errors, stack){\r\n\t\tif (isObject(obj)){\r\n\t\t\tlet def = this.definition\r\n\t\t\tcheckDefinition(obj, def, path, errors, stack)\r\n\t\t\tif(this.sealed) checkUndeclaredProps(obj, def, errors)\r\n\t\t}\r\n\t\telse stackError(errors, this, obj, path)\r\n\r\n\t\tcheckAssertions(obj, this, path, errors)\r\n\t}\r\n})\r\n\r\nlet getProxy = (model, obj, def, path) => !isPlainObject(def) ? cast(obj, def) : proxify(obj, {\r\n\r\n\tgetPrototypeOf: () => path ? ObjectProto : getProto(obj),\r\n\r\n\tget(o, key) {\r\n\t\tif (!isString(key))\r\n\t\t\treturn Reflect.get(o, key)\r\n\r\n\t\tlet newPath = getPath(path, key),\r\n\t\t    defPart = def[key];\r\n\r\n\t\tif (key in def && model.conventionForPrivate(key)) {\r\n\t\t\tcannot(`access to private property ${newPath}`, model)\r\n\t\t\tunstackErrors(model)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (o[key] && has(o, key) && !isPlainObject(defPart) && !isModelInstance(o[key])) {\r\n\t\t\to[key] = cast(o[key], defPart) // cast nested models\r\n\t\t}\r\n\r\n\t\tif (isFunction(o[key]) && o[key].bind)\r\n\t\t\treturn o[key].bind(o); // auto-bind methods to original object, so they can access private props\r\n\r\n\t\tif(isPlainObject(defPart) && !o[key]){\r\n\t\t\to[key] = {} // null-safe traversal\r\n\t\t}\r\n\r\n\t\treturn getProxy(model, o[key], defPart, newPath)\r\n\t},\r\n\r\n\tset(o, key, val) {\r\n\t\treturn controlMutation(model, def, path, o, key, (newPath) => {\r\n\t\t\tReflect.set(o, key, getProxy(model, val, def[key], newPath))\r\n\t\t})\r\n\t},\r\n\r\n\tdeleteProperty(o, key) {\r\n\t\treturn controlMutation(model, def, path, o, key, () => Reflect.deleteProperty(o, key))\r\n\t},\r\n\r\n\tdefineProperty(o, key, args){\r\n\t\treturn controlMutation(model, def, path, o, key, () => Reflect.defineProperty(o, key, args))\r\n\t},\r\n\r\n\thas(o, key){\r\n\t\treturn Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)\r\n\t},\r\n\r\n\townKeys(){\r\n\t\treturn Reflect.ownKeys(def).filter(key => !model.conventionForPrivate(key))\r\n\t},\r\n\r\n\tgetOwnPropertyDescriptor(o, key){\r\n\t\tlet descriptor;\r\n\t\tif (!model.conventionForPrivate(key)) {\r\n\t\t\tdescriptor = Object.getOwnPropertyDescriptor(def, key);\r\n\t\t\tif (descriptor !== undefined) descriptor.value = o[key];\r\n\t\t}\r\n\r\n\t\treturn descriptor\r\n\t}\r\n})\r\n\r\nlet checkUndeclaredProps = (obj, def, errors, path) => {\r\n\tmapProps(obj, key => {\r\n\t\tlet val = obj[key],\r\n\t\t    subpath = getPath(path, key)\r\n\t\tif(!has(def, key)) rejectUndeclaredProp(subpath, val, errors)\r\n\t\telse if(isPlainObject(val))\tcheckUndeclaredProps(val, def[key], errors, subpath)\r\n\t})\r\n}\r\n\r\nlet controlMutation = (model, def, path, o, key, applyMutation) => {\r\n\tlet newPath       = getPath(path, key),\r\n\t    isPrivate     = model.conventionForPrivate(key),\r\n\t    isConstant    = model.conventionForConstant(key),\r\n\t    isOwnProperty = has(o, key),\r\n\t    initialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key)\r\n\r\n\tif (key in def && (isPrivate || (isConstant && o[key] !== undefined)))\r\n\t\tcannot(`modify ${isPrivate ? \"private\" : \"constant\"} ${key}`, model)\r\n\r\n\tlet isInDefinition = has(def, key);\r\n\tif (isInDefinition || !model.sealed) {\r\n\t\tapplyMutation(newPath)\r\n\t\tisInDefinition && checkDefinition(o[key], def[key], newPath, model.errors, [])\r\n\t\tcheckAssertions(o, model, newPath)\r\n\t}\r\n\telse rejectUndeclaredProp(newPath, o[key], model.errors)\r\n\r\n\tlet nbErrors = model.errors.length\r\n\tif (nbErrors) {\r\n\t\tif (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor)\r\n\t\telse delete o[key] // back to the initial property defined in prototype chain\r\n\r\n\t\tunstackErrors(model)\r\n\t}\r\n\r\n\treturn !nbErrors\r\n}\r\n\r\nlet rejectUndeclaredProp = (path, received, errors) => {\r\n\terrors.push({\r\n\t\tpath,\r\n\t\treceived,\r\n\t\tmessage: `property ${path} is not declared in the sealed model definition`\r\n\t})\r\n}","import {_constructor, _validate, bettertypeof, define, extend, format, isArray, isPlainObject} from \"./helpers\"\r\nimport {checkAssertions, checkDefinition, formatDefinition} from \"./definition\"\r\nimport BasicModel from \"./basic-model\"\r\nimport ObjectModel from \"./object-model\"\r\n\r\nexport function Model(def, params) {\r\n\treturn isPlainObject(def) ? new ObjectModel(def, params) : new BasicModel(def)\r\n}\r\n\r\nObject.assign(Model.prototype, {\r\n\tname: \"Model\",\r\n\tassertions: [],\r\n\r\n\tconventionForConstant: key => key.toUpperCase() === key,\r\n\tconventionForPrivate: key => key[0] === \"_\",\r\n\r\n\ttoString(stack){\r\n\t\treturn formatDefinition(this.definition, stack)\r\n\t},\r\n\r\n\tas(name){\r\n\t\tdefine(this, \"name\", name);\r\n\t\treturn this\r\n\t},\r\n\r\n\tdefaultTo(val){\r\n\t\tthis.default = val\r\n\t\treturn this\r\n\t},\r\n\r\n\t[_constructor]: o => o,\r\n\r\n\t[_validate](obj, path, errors, stack){\r\n\t\tcheckDefinition(obj, this.definition, path, errors, stack)\r\n\t\tcheckAssertions(obj, this, path, errors)\r\n\t},\r\n\r\n\tvalidate(obj, errorCollector){\r\n\t\tthis[_validate](obj, null, this.errors, [])\r\n\t\treturn !unstackErrors(this, errorCollector)\r\n\t},\r\n\r\n\ttest(obj){\r\n\t\tlet failed,\r\n\t\t    initialErrorCollector = this.errorCollector\r\n\r\n\t\tthis.errorCollector = () => {\r\n\t\t\tfailed = true\r\n\t\t}\r\n\r\n\t\tnew this(obj) // may trigger this.errorCollector\r\n\r\n\t\tthis.errorCollector = initialErrorCollector\r\n\t\treturn !failed\r\n\t},\r\n\r\n\terrorCollector(errors){\r\n\t\tlet e = new TypeError(errors.map(e => e.message).join('\\n'))\r\n\t\te.stack = e.stack.replace(/\\n.*object-model(.|\\n)*object-model.*/, \"\") // blackbox objectmodel in stacktrace\r\n\t\tthrow e\r\n\t},\r\n\r\n\tassert(assertion, description = format(assertion)){\r\n\t\tdefine(assertion, \"description\", description);\r\n\t\tthis.assertions = this.assertions.concat(assertion)\r\n\t\treturn this\r\n\t}\r\n})\r\n\r\nexport let initModel = (model, def) => {\r\n\tmodel.definition = def\r\n\tmodel.assertions = [...model.assertions]\r\n\tdefine(model, \"errors\", [])\r\n\tdelete model.name;\r\n}\r\n\r\nexport let extendModel = (child, parent, newProps) => {\r\n\textend(child, parent, newProps)\r\n\tchild.assertions.push(...parent.assertions)\r\n\treturn child\r\n}\r\n\r\nexport let stackError = (errors, expected, received, path, message) => {\r\n\terrors.push({expected, received, path, message})\r\n}\r\n\r\nexport let unstackErrors = (model, errorCollector = model.errorCollector) => {\r\n\tlet nbErrors = model.errors.length\r\n\tif (nbErrors > 0) {\r\n\t\tlet errors = model.errors.map(err => {\r\n\t\t\tif (!err.message) {\r\n\t\t\t\tlet def = isArray(err.expected) ? err.expected : [err.expected]\r\n\t\t\t\terr.message = \"expecting \" + (err.path ? err.path + \" to be \" : \"\") + def.map(d => format(d)).join(\" or \")\r\n\t\t\t\t\t+ \", got \" + (err.received != null ? bettertypeof(err.received) + \" \" : \"\") + format(err.received)\r\n\t\t\t}\r\n\t\t\treturn err\r\n\t\t})\r\n\t\tmodel.errors = []\r\n\t\terrorCollector.call(model, errors) // throw all errors collected\r\n\t}\r\n\treturn nbErrors\r\n}\r\n\r\nexport default Model","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isArray, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nlet ARRAY_MUTATORS = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"]\n\nexport default function ArrayModel(def) {\n\n\tlet model = function (array = model.default) {\n\t\tif (model.validate(array)) return proxifyModel(array, model, {\n\t\t\tget(arr, key) {\n\t\t\t\tlet val = arr[key];\n\t\t\t\treturn isFunction(val) ? proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (ARRAY_MUTATORS.includes(key)) {\n\t\t\t\t\t\tlet testArray = arr.slice()\n\t\t\t\t\t\tfn.apply(testArray, args)\n\t\t\t\t\t\tmodel.validate(testArray)\n\t\t\t\t\t}\n\n\t\t\t\t\tlet returnValue = fn.apply(arr, args)\n\t\t\t\t\tarray.forEach((a, i) => arr[i] = cast(a, model.definition))\n\t\t\t\t\treturn returnValue\n\t\t\t\t}) : val\n\t\t\t},\n\n\t\t\tset(arr, key, val) {\n\t\t\t\treturn setArrayKey(arr, key, val, model)\n\t\t\t},\n\n\t\t\tdeleteProperty(arr, key){\n\t\t\t\treturn !(key in arr) || setArrayKey(arr, key, undefined, model)\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Array)\n\tsetConstructor(model, ArrayModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(ArrayModel, Model, {\n\ttoString(stack){\n\t\treturn 'Array of ' + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](arr, path, errors, stack){\n\t\tif (isArray(arr))\n\t\t\tarr.forEach((a, i) => {\n\t\t\t\tarr[i] = checkDefinition(a, this.definition, `${path || \"Array\"}[${i}]`, errors, stack)\n\t\t\t})\n\t\telse stackError(errors, this, arr, path)\n\n\t\tcheckAssertions(arr, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})\n\nlet setArrayKey = (array, key, value, model) => {\n\tlet path = `Array[${key}]`;\n\tif (parseInt(key) === +key && key >= 0)\n\t\tvalue = checkDefinition(value, model.definition, path, model.errors, [])\n\n\tlet testArray = array.slice()\n\ttestArray[key] = value\n\tcheckAssertions(testArray, model, path)\n\tlet isSuccess = !unstackErrors(model)\n\tif (isSuccess) array[key] = value\n\treturn isSuccess\n}","import {extendModel, initModel, Model, stackError, unstackErrors} from \"./model\"\nimport {checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyModel, setConstructor} from \"./helpers\"\n\n\nexport default function FunctionModel(...argsDef) {\n\n\tlet model = function (fn = model.default) {\n\t\tif (!model.validate(fn)) return\n\t\treturn proxifyModel(fn, model, {\n\t\t\tapply (fn, ctx, args) {\n\t\t\t\tlet def = model.definition\n\n\t\t\t\tdef.arguments.forEach((argDef, i) => {\n\t\t\t\t\targs[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [])\n\t\t\t\t})\n\n\t\t\t\tcheckAssertions(args, model, \"arguments\")\n\n\t\t\t\tlet result\n\t\t\t\tif (!model.errors.length) {\n\t\t\t\t\tresult = Reflect.apply(fn, ctx, args)\n\t\t\t\t\tif (\"return\" in def)\n\t\t\t\t\t\tresult = checkDefinition(result, def.return, \"return value\", model.errors, [])\n\t\t\t\t}\n\t\t\t\tunstackErrors(model)\n\t\t\t\treturn result\n\t\t\t}\n\t\t});\n\t}\n\n\textend(model, Function)\n\tsetConstructor(model, FunctionModel)\n\tinitModel(model, {arguments: argsDef})\n\n\treturn model\n}\n\nextend(FunctionModel, Model, {\n\ttoString(stack = []){\n\t\tlet out = `Function(${this.definition.arguments.map(\n\t\t\targDef => formatDefinition(argDef, stack.slice())\n\t\t).join(\",\")})`\n\n\t\tif (\"return\" in this.definition) {\n\t\t\tout += \" => \" + formatDefinition(this.definition.return, stack)\n\t\t}\n\t\treturn out\n\t},\n\n\treturn(def){\n\t\tthis.definition.return = def\n\t\treturn this\n\t},\n\n\textend(newArgs, newReturns) {\n\t\tlet args = this.definition.arguments,\n\t\t    mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i])),\n\t\t    mixedReturns = extendDefinition(this.definition.return, newReturns)\n\t\treturn extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)\n\t},\n\n\t[_validate](f, path, errors){\n\t\tif (!isFunction(f)) {\n\t\t\tstackError(errors, \"Function\", f, path)\n\t\t}\n\t}\n})\n\nFunctionModel.prototype.assert(function (args) {\n\treturn (args.length > this.definition.arguments.length) ? args : true\n}, function (args) {\n\treturn `expecting ${this.definition.arguments.length} arguments for ${format(this)}, got ${args.length}`\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, format, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nlet MAP_MUTATORS = [\"set\", \"delete\", \"clear\"]\n\nexport default function MapModel(key, value) {\n\n\tlet model = function (iterable = model.default) {\n\t\tlet castKeyValue = pair => [\"key\", \"value\"].map((prop, i) => cast(pair[i], model.definition[prop])),\n\t\t    map = new Map([...iterable].map(castKeyValue))\n\n\t\tif (!model.validate(map)) return\n\n\t\treturn proxifyModel(map, model, {\n\t\t\tget(map, key) {\n\t\t\t\tlet val = map[key];\n\t\t\t\treturn isFunction(val) ? proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"set\") {\n\t\t\t\t\t\targs = castKeyValue(args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (MAP_MUTATORS.includes(key)) {\n\t\t\t\t\t\tlet testMap = new Map(map)\n\t\t\t\t\t\tfn.apply(testMap, args)\n\t\t\t\t\t\tmodel.validate(testMap)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(map, args)\n\t\t\t\t}) : val\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Map)\n\tsetConstructor(model, MapModel)\n\tinitModel(model, {key, value})\n\treturn model\n}\n\nextend(MapModel, Model, {\n\ttoString(stack) {\n\t\tlet {key, value} = this.definition\n\t\treturn `Map of ${formatDefinition(key, stack)} : ${formatDefinition(value, stack)}`\n\t},\n\n\t[_validate](map, path, errors, stack) {\n\t\tif (map instanceof Map) {\n\t\t\tpath = path || 'Map'\n\t\t\tfor (let [key, value] of map) {\n\t\t\t\tcheckDefinition(key, this.definition.key, `${path} key`, errors, stack)\n\t\t\t\tcheckDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, map, path)\n\n\t\tcheckAssertions(map, this, path, errors)\n\t},\n\n\textend(newKeys, newValues){\n\t\tlet {key, value} = this.definition\n\t\treturn extendModel(new MapModel(extendDefinition(key, newKeys), extendDefinition(value, newValues)), this)\n\t}\n})","import {extendModel, initModel, Model, stackError} from \"./model\"\nimport {cast, checkAssertions, checkDefinition, extendDefinition, formatDefinition} from \"./definition\"\nimport {_validate, extend, isFunction, proxifyFn, proxifyModel, setConstructor} from \"./helpers\"\n\nlet SET_MUTATORS = [\"add\", \"delete\", \"clear\"]\n\nexport default function SetModel(def) {\n\n\tlet model = function (iterable = model.default) {\n\t\tlet castValue = val => cast(val, model.definition),\n\t\t    set = new Set([...iterable].map(castValue))\n\n\t\tif (!model.validate(set)) return\n\n\t\treturn proxifyModel(set, model, {\n\t\t\tget(set, key) {\n\t\t\t\tlet val = set[key]\n\t\t\t\treturn isFunction(val) ? proxifyFn(val, (fn, ctx, args) => {\n\t\t\t\t\tif (key === \"add\") {\n\t\t\t\t\t\targs[0] = castValue(args[0])\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SET_MUTATORS.includes(key)) {\n\t\t\t\t\t\tlet testSet = new Set(set)\n\t\t\t\t\t\tfn.apply(testSet, args)\n\t\t\t\t\t\tmodel.validate(testSet)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(set, args)\n\t\t\t\t}) : val\n\t\t\t}\n\t\t})\n\t}\n\n\textend(model, Set)\n\tsetConstructor(model, SetModel)\n\tinitModel(model, def)\n\treturn model\n}\n\nextend(SetModel, Model, {\n\ttoString(stack){\n\t\treturn \"Set of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_validate](set, path, errors, stack){\n\t\tif (set instanceof Set) {\n\t\t\tfor (let item of set.values()) {\n\t\t\t\tcheckDefinition(item, this.definition, `${path || \"Set\"} value`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, set, path)\n\t\tcheckAssertions(set, this, path, errors)\n\t},\n\n\textend(...newParts){\n\t\treturn extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})","import Model from \"./model\"\r\n\r\nexport const\r\n\t_constructor = \"_constructor\",\r\n\t_validate = \"_validate\",\r\n\r\n\tObjectProto     = Object.prototype,\r\n\tbettertypeof    = x => ObjectProto.toString.call(x).match(/\\s([a-zA-Z]+)/)[1],\r\n\tgetProto        = Object.getPrototypeOf,\r\n\r\n\thas             = (o, prop) => o.hasOwnProperty(prop),\r\n\tis              = (Constructor, obj) => obj instanceof Constructor,\r\n\tisString        = s => typeof s === \"string\",\r\n\tisFunction      = f => typeof f === \"function\",\r\n\tisObject        = o => typeof o === \"object\",\r\n\tisArray         = a => Array.isArray(a),\r\n\tisPlainObject   = o => o && isObject(o) && getProto(o) === ObjectProto,\r\n\tisModelInstance = i => i && is(Model, getProto(i).constructor),\r\n\r\n\tproxify      = (val, traps) => new Proxy(val, traps),\r\n\tproxifyFn    = (fn, apply) => proxify(fn, {apply}),\r\n\tproxifyModel = (val, model, traps) => proxify(val, Object.assign({ getPrototypeOf: () => model.prototype }, traps)),\r\n\r\n\tcannot   = (msg, model) => { model.errors.push({message: \"cannot \" + msg}) },\r\n\tgetPath  = (path, key) => path ? path + '.' + key : key,\r\n\tmapProps = (o, fn) => Object.keys(o).map(fn)\r\n\r\n\r\nexport let merge = (target, src = {}, deep) => {\r\n\tfor (let key in src) {\r\n\t\tif (deep && isPlainObject(src[key])) {\r\n\t\t\tlet o = {}\r\n\t\t\tmerge(o, target[key], deep)\r\n\t\t\tmerge(o, src[key], deep)\r\n\t\t\ttarget[key] = o\r\n\t\t} else {\r\n\t\t\ttarget[key] = src[key]\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport let define = (obj, key, value, enumerable = false) => {\r\n\tObject.defineProperty(obj, key, {value, enumerable, writable: true, configurable: true})\r\n}\r\n\r\nexport let setConstructor = (model, constructor) => {\r\n\tObject.setPrototypeOf(model, constructor.prototype)\r\n\tdefine(model, \"constructor\", constructor)\r\n}\r\n\r\nexport let extend = (child, parent, props) => {\r\n\tchild.prototype = Object.assign(Object.create(parent.prototype, {\r\n\t\tconstructor: {\r\n\t\t\tvalue: child,\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true\r\n\t\t}\r\n\t}), props)\r\n\tObject.setPrototypeOf(child, parent)\r\n}\r\n\r\nexport let format = (obj, stack = []) => {\r\n\tif (stack.length > 15 || stack.includes(obj)) return '...'\r\n\tif (obj === null || obj === undefined) return String(obj)\r\n\tif (isString(obj)) return `\"${obj}\"`\r\n\tif (is(Model, obj)) return obj.toString(stack)\r\n\r\n\tstack.unshift(obj)\r\n\r\n\tif (isFunction(obj)) return obj.name || obj.toString(stack)\r\n\tif (is(Map, obj) || is(Set, obj)) return format([...obj])\r\n\tif (isArray(obj)) return `[${obj.map(item => format(item, stack)).join(', ')}]`\r\n\tif (obj.toString !== Object.prototype.toString) return obj.toString()\r\n\tif (obj && isObject(obj)) {\r\n\t\tlet props  = Object.keys(obj),\r\n\t\t    indent = '\\t'.repeat(stack.length)\r\n\t\treturn `{${props.map(\r\n\t\t\tkey => `\\n${indent + key}: ${format(obj[key], stack.slice())}`\r\n\t\t).join(',')} ${props.length ? `\\n${indent.slice(1)}` : ''}}`\r\n\t}\r\n\r\n\treturn String(obj)\r\n}","import {\n\t_validate,\n\tformat,\n\tis,\n\tisArray,\n\tisFunction,\n\tisModelInstance,\n\tisPlainObject,\n\tgetPath,\n\tmapProps\n} from \"./helpers\"\n\nimport {Model, stackError} from \"./model\"\n\nexport let parseDefinition = (def) => {\n\tif (isPlainObject(def)) {\n\t\tmapProps(def, key => { def[key] = parseDefinition(def[key]) })\n\t}\n\telse if (!isArray(def)) return [def]\n\telse if (def.length === 1) return [...def, undefined, null]\n\n\treturn def\n}\n\nexport let formatDefinition = (def, stack) => parseDefinition(def).map(d => format(d, stack)).join(\" or \")\n\nexport let extendDefinition = (def, newParts = []) => {\n\tif (!isArray(newParts)) newParts = [newParts]\n\tif (newParts.length > 0) {\n\t\tdef = newParts\n\t\t\t.reduce((def, ext) => def.concat(ext), isArray(def) ? def.slice() : [def]) // clone to lose ref\n\t\t\t.filter((value, index, self) => self.indexOf(value) === index) // remove duplicates\n\t}\n\n\treturn def\n}\n\nexport let checkDefinition = (obj, def, path, errors, stack) => {\n\tlet indexFound = stack.indexOf(def)\n\tif (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)\n\t\treturn obj //if found twice in call stack, cycle detected, skip validation\n\n\tobj = cast(obj, def)\n\n\tif (is(Model, def)) {\n\t\tdef[_validate](obj, path, errors, stack.concat(def))\n\t}\n\telse if (isPlainObject(def)) {\n\t\tmapProps(def, key => {\n\t\t\tcheckDefinition(obj ? obj[key] : undefined, def[key], getPath(path, key), errors, stack)\n\t\t})\n\t}\n\telse {\n\t\tlet pdef = parseDefinition(def)\n\t\tif (pdef.some(part => checkDefinitionPart(obj, part, path, stack)))\n\t\t\treturn obj\n\n\t\tstackError(errors, def, obj, path)\n\t}\n\n\treturn obj\n}\n\nexport let checkDefinitionPart = (obj, def, path, stack) => {\n\tif (obj == null) return obj === def\n\tif (isPlainObject(def) || is(Model, def)) { // object or model as part of union type\n\t\tlet errors = []\n\t\tcheckDefinition(obj, def, path, errors, stack)\n\t\treturn !errors.length\n\t}\n\tif (is(RegExp, def)) return def.test(obj)\n\tif (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)\n\treturn obj === def\n\t\t|| (isFunction(def) && is(def, obj))\n\t\t|| obj.constructor === def\n}\n\nexport let checkAssertions = (obj, model, path, errors = model.errors) => {\n\tfor (let assertion of model.assertions) {\n\t\tlet result\n\t\ttry {\n\t\t\tresult = assertion.call(model, obj)\n\t\t} catch (err) {\n\t\t\tresult = err\n\t\t}\n\t\tif (result !== true) {\n\t\t\tlet onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>\n\t\t\t\t`assertion \"${assertion.description}\" returned ${format(assertionResult)} `\n\t\t\t\t+`for ${path ? path+\" =\" : \"value\"} ${format(value)}`\n\t\t\tstackError(errors, assertion, obj, path, onFail.call(model, result, obj, path))\n\t\t}\n\t}\n}\n\nexport let cast = (obj, defNode = []) => {\n\tif (!obj || isPlainObject(defNode) || isModelInstance(obj))\n\t\treturn obj // no value or not leaf or already a model instance\n\n\tlet def = parseDefinition(defNode),\n\t    suitableModels = []\n\n\tfor (let part of def) {\n\t\tif (is(Model, part) && part.test(obj))\n\t\t\tsuitableModels.push(part)\n\t}\n\n\tif (suitableModels.length === 1)\n\t\treturn suitableModels[0](obj) // automatically cast to suitable model when explicit\n\n\tif (suitableModels.length > 1)\n\t\tconsole.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(\" or \")}`)\n\n\treturn obj\n}"],"names":["BasicModel","def","model","val","default","validate","undefined","setConstructor","initModel","ObjectModel","params","obj","instance","this","is","merge","_constructor","getProxy","definition","Object","assign","extend","Model","isPlainObject","ArrayModel","array","proxifyModel","[object Object]","arr","key","isFunction","proxifyFn","fn","ctx","args","ARRAY_MUTATORS","includes","testArray","slice","apply","returnValue","forEach","a","i","cast","setArrayKey","Array","FunctionModel","argsDef","arguments","argDef","checkDefinition","errors","checkAssertions","result","length","Reflect","return","unstackErrors","Function","MapModel","value","iterable","castKeyValue","pair","map","prop","Map","MAP_MUTATORS","testMap","SetModel","castValue","set","Set","SET_MUTATORS","testSet","_validate","ObjectProto","prototype","bettertypeof","x","toString","call","match","getProto","getPrototypeOf","has","o","hasOwnProperty","Constructor","isString","s","f","isObject","isArray","isModelInstance","constructor","proxify","traps","Proxy","cannot","msg","push","message","getPath","path","mapProps","keys","target","src","deep","define","enumerable","defineProperty","writable","configurable","setPrototypeOf","child","parent","props","create","format","stack","String","unshift","name","item","join","indent","repeat","parseDefinition","formatDefinition","d","extendDefinition","newParts","reduce","ext","concat","filter","index","self","indexOf","indexFound","pdef","some","part","checkDefinitionPart","stackError","RegExp","test","Number","Date","isNaN","assertion","assertions","err","onFail","description","assertionResult","defNode","suitableModels","console","warn","extendModel","sealed","p","newAssertions","proto","submodel","parentInstance","checkUndeclaredProps","get","newPath","defPart","conventionForPrivate","bind","controlMutation","deleteProperty","ownKeys","descriptor","getOwnPropertyDescriptor","subpath","rejectUndeclaredProp","applyMutation","isPrivate","isConstant","conventionForConstant","isOwnProperty","initialPropDescriptor","isInDefinition","nbErrors","received","toUpperCase","errorCollector","failed","initialErrorCollector","e","TypeError","replace","newProps","expected","parseInt","isSuccess","out","newArgs","newReturns","mixedArgs","mixedReturns","assert","newKeys","newValues","values"],"mappings":"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"}